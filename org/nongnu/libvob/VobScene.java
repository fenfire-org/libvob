/*
VobScene.java
 *    
 *    Copyright (c) 2000-2002, Ted Nelson and Tuomas Lukka
 *
 *    This file is part of Gzz.
 *    
 *    Gzz is free software; you can redistribute it and/or modify it under
 *    the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *    
 *    Gzz is distributed in the hope that it will be useful, but WITHOUT
 *    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
 *    Public License for more details.
 *    
 *    You should have received a copy of the GNU General
 *    Public License along with Gzz; if not, write to the Free
 *    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 *    MA  02111-1307  USA
 *    
 *
 */
/*
 * Written by Tuomas Lukka
 */
package org.nongnu.libvob;
import java.awt.*;

/** A scene (keyframe) into which Vobs are placed.
 * <p>
 * A VobScene encapsulates three separate systems: simple and orthogonal 
 * coordinate systems, coordinate system mathing and coordinate systems 
 * mapping for vobs. These systems are used to control the 
 * main canvas called screen. VobScene can be used to make child coordinate 
 * systems to this main canvas or to the coordinate system already made.
 * So, all coordinate systems have parent coordinate system which is screen or 
 * some other coordinate system created before. Once coordinate systems are 
 * created and <i>matched</i> correctly there's no doubt to <i>map</i> a Vob 
 * in the scene/screen/main canvas with <i>coordinate systems</i> given.
 * <p>
 * One important thing with one coordinate system is that they are 
 * systems which origin(0,0) is in up-left corner and point(1,1) is 
 * in down-right corner.
 * <p>
 * A VobScene is somewhat like a scene graph but has some rather special features.
 * Usually, VobScenes are <b>not</b> re-used between key presses: instead, the previous
 * scene (keyframe) is saved, a new one is generated, and an interpolation between
 * the two is generated by using the <i>keys</i> of the coordinate systems.
 * <p>
 * The VobScene is an aggregate of objects which perform different aspects of its function:
 * VobCoorder keeps track of the coordinate systems defined in the VobScene,
 * VobMap keeps track of which Vobs use which coordinate systems
 * and VobMatcher keeps track of the keys of the coordinate systems.
 * <p>
 * For example,
 * <pre>
        // create a new coordinate system, at (100,100), scaled
        // by 100 in x-direction and 50 in y-direction. 
	// In this coordinate system, the point (0,0) is mapped to (100,100) on screen
	// and the point (1,1) is mapped to (200,50) because screen is the 0 coordinate system. 
	int cs = vs.coords.ortho(0, 0, 100, 100, 100, 50);
	
	// set key of the coordinate system.
	vs.matcher.add(cs, "MYVOB");

	// Place a vob into it.
	vs.map.put(vob, cs);
 * </pre>
 * places a single vob into a single coordinate system. Now, when generating
 * the next keyframe, if we do
 * <pre>
 	// Lower down and narrower
	int cs2 = vs2.coords.ortho(0, 0, 100, 200, 50, 50);
	
	vs2.matcher.add(cs2, "MYVOB");

	vs2.map.put(vob, cs2);
 * </pre>
 * The VobScene can be used to generate an animation from vs to vs2, smoothly animating
 * the location and size of the vob (by animating the coordinate system).
 * The VobScene contains shortcuts for the above code:
   <pre>
	vs.put(vob, "MYVOB", 0, 100, 100, 100, 50);

	vs2.put(vob, "MYVOB", 0, 100, 200, 50, 50);
   </pre>
   has the same effect as the above code.
 * <p>
 * It is perfectly allowable to leave the keys undefined; this simply means that the
 * coordinate systems which have no keys should not be interpolated.
 * <p>
 * Coordinate systems can be nested, and here's a difficult bit: there are actually
 * two distinct hierarchies here: the transformations and the keys form their own,
 * separate hierarchies. 
   <pre>
	int cs = vs.coords.ortho(0, 0, 100, 100, 100, 50);

	// A translation RELATIVE to cs: the origin of cs_t is at (150, 125) on screen.
	int cs_t = vs.coords.translate(0, .5, .5, 0);

	vs.matcher.add(cs, "V1");
	// Sub key
	vs.matcher.add(cs, cs_t, "X");
   </pre>
    Now, cs_t will only be interpolated to a coordinate system whose parent is interpolated
    to cs, and whose key is "X".
    Here, both hierarchies were parallel, and indeed, usually they are. But sometimes
    non-parallel hierarchies are useful. For example, if we are placing images next to a map
    and markers on the map about where those images are, it's easier to do
    <pre>
	void placeImage(int imageCS, int mapCS, String param) {
	    // Place image into the image coordsys
	    // ...
	    int marker_cs = vs.coords.ortho(mapCS, 0, markx, marky, w, h);
	    vs.matcher.add(imageCS, marker_cs, "MARK");
	}
    </pre>
    Here, the marker <i>transformation</i> is a child of the map transformation, but
    as a <i>keyframe object,</i> for matching, its parent is imageCS.
    This allows us to use the constant key "MARK" for all the marks.
    <p>
    However, you'll probably see this situation pretty rarely; most often the hierarchies
    are indeed parallel, and for that case VobScene provides a shortcut:
    <pre>
	int cs = vs.orthoCS(0, "V1", 0, 100, 100, 100, 50);
	int cs_t = vs.translateCS(cs, "X", .5, .5, 0);
    </pre>
    has the same effect as the earlier code.
 * <p>
 *
 */

public class VobScene {
    public final VobMap map;
    public final VobCoorder coords;
    public final VobMatcher matcher;

    public WindowAnimation anim = null;
    public final Actions actions;

    public final GraphicsAPI gfxapi;
    public final GraphicsAPI.RenderingSurface window;

    private final AffineVobCoorder af() {
	if(coords instanceof AffineVobCoorder)
	    return (AffineVobCoorder)coords;
	throw new NotAffineVobCoorderException();
    }

    public Dimension size;
    public VobScene(VobMap m, VobCoorder c, VobMatcher mat,
			    GraphicsAPI gfxapi, 
			    GraphicsAPI.RenderingSurface window,
				Dimension size) { 
	this.map = m; 
	m.setVS(this);
	this.coords = c; 
	this.matcher = mat;
	this.gfxapi = gfxapi;
	this.window = window;
	this.size = size;
	this.actions = new org.nongnu.libvob.impl.ActionsImpl(this);
    }

    /** Create an orthogonal coordinate system. For example
     * <pre>
            int cs = vs.coords.ortho(0, 0, 100, 100, 100, 50);
     * </pre> 
     * create a new coordinate system, at (100,100) in screen coordinates,
     * scaled by 100 in x-direction and 50 in y-direction.
     */
    final public int orthoCS(int into, Object key, float depth, 
				float x, float y, float sx, float sy) {
	return matcher.add(into, coords.ortho(into,
			depth, x, y, sx, sy), key);
    }
    final public int translateCS(int into, Object key, float x, float y) {
	return matcher.add(into, coords.translate(into, x, y), key);
    }
    public int translateCS(int into, Object key, 
		    float x, float y, float z) {
	return matcher.add(into, coords.translate(into, x, y, z), key);
    }
    /** Create a scaled coordinate system. The point scale to is origin.
     */
    public int scaleCS(int into, Object key, float sx, float sy) {
	return matcher.add(into, coords.scale(into, sx, sy), key);
    }

    /** Creates an affine coordinate system.
     * AffineCS allows skewing and rotation, i.e. a general 2D affine 
     * transformation and Z translation.
     * <p>
     * OrthoCS has the new x coordinate depend only on the old X coordinate,
     * here it can depend both on the old X and Y coordinates.
     */
    public int affineCS(int into, Object key,
	    float depth, float cx, float cy,
	    float x_x, float x_y, float y_x, float y_y) {
	return matcher.add(into, 
		af().affine(into, depth, cx, cy,
			x_x, x_y, y_x, y_y), key
	    );
    }

    /** Create rotated coordinate system. Rotating point is origin.
     */
    public int rotateCS(int into, Object key, float degrees) {
	return matcher.add(into, af().rotate(into, degrees), key);
    }

    /** Create a scaled coordinate system. The point scale to is origin.
     */
    public int scaleCS(int into, Object key, 
			    float sx, float sy, float sz) {
	return matcher.add(into, af().scale(into, sx, sy, sz), key);
    }

    /** create a coordinate system such that its unit square
     * goes orthogonally to the parent's box.
     * I.e. if parent's box is (40,20)
     * then (.5,.5) in the new coordsys maps to (20,10).
     * It's basically a scale() which takes its parameters from the parent.
     */
    public int unitSqCS(int into, Object key) {
	return matcher.add(into, coords.unitSq(into), key);
    }
    public int boxCS(int into, Object key, float w, float h) {
	return matcher.add(into, coords.box(into, w, h), key);
    }
    public int boxCS(int into, Object key, float x, float y, 
		     float w, float h) {
	return matcher.add(into, coords.box(into, x, y, w, h), key);
    }
    public int boxCS(int into, Object key, float d, float x, float y, 
		     float w, float h) {
	return matcher.add(into, coords.box(into, d, x, y, w, h), key);
    }
    public int orthoBoxCS(int into, Object key, 
			    float d, float x, float y, 
			    float sx, float sy, 
			    float w, float h) {
	return matcher.add(into, coords.orthoBox(into, d, x, y, sx, sy, w, h), key);
    }

    public int cullCS(int into, Object key, int clip) {
	return matcher.add(into, coords.cull(into, clip), key);
    }
    public int cullCS(int into, Object key, int test, int clip) {
	return matcher.add(into, coords.cull(into, test, clip), key);
    }

    public int concatCS(int into, Object key, int other) {
	return matcher.add(into, coords.concat(into, other), key);
    }
    public int invertCS(int into, Object key) {
	return matcher.add(into, coords.invert(into), key);
    }

    /** Determines size of the area designated for the <code>Vob</code>s.
     *  At least at the moment doesn't include margins.
     * Coordinates of the scene's
     *  designated area run from (0,0) to (w-1, h-1).
     *  @return dimensions of the scene area in pixels
     */
    public java.awt.Dimension getSize() {
	return size;
    }

    // deprecated...
    public void put(Vob v, int d, int x, int y, int w, int h) {
	put(v, null, d, x, y, w, h);
    }
    public void put(Vob v, Object key, float d, float x, float y, float w, float h) {
	int c = coords.ortho(0, d, x, y, w, h);
	if(key != null)
	    matcher.add(c, key);
	map.put(v, c);
    }

    /** Place the given VobScene as a child.
     * The given VobScene must not be modified after this call.
     * @param child The child VobScene to place. Child vobscenes
     * 		need to be created especially, through
     *		RenderingSurface.createChildVobScene
     * @param key The key to use
     * @param cs The coordinate systems that shall be used as the first
     *           coordinate systems of the child.
     *           This *must* have the same number of elements as 
     *           the createChildVobScene method was given.
     */
    public int putChildVobScene(ChildVobScene child, Object key, int[] cs) {
	int id = coords._putChildVobScene(child, cs);
	matcher.add(id, key);
	map._putChildVobScene(child, id, cs);
	return id;
    }

    /** Get a coordinate system from a child vobscene placed
     * using putChildVobScene into this VobScene.
     * @param childVobSceneId The id returned from putChildVobScene
     * @param nth The index of the coordinate system 
     *            inside the child vobscene.
     */
    public int exportChildCoordsys(int childVobSceneId, int nth) {
	return coords.exportChildCoordsys(childVobSceneId, nth);
    }


    /** Cause the given coordinate system to be considered when 
     * getCSAt() is called.
     */
    public void activate(int cs) {
	coords.activate(cs);
    }
    public void activate(Object key) {
	coords.activate(matcher.getCS(key));
    }

    /** Get the topmost activated coordsys at (x,y), whose nearest activated
     *  direct ancestor (not determining) is parent.
     */
    public int getCSAt(int parent, float x, float y, float[] targetcoords) {
	return coords.getCSAt(parent, x, y, targetcoords);
    }

    public Object getKeyAt(int parent, float x, float y, float[] targetcoords) {
	int cs = coords.getCSAt(parent, x, y, targetcoords);
	if(cs < 0) return null;
	return matcher.getKey(cs);
    }


    public void put(Vob vob) { map.put(vob); }
    public void put(Vob vob, int cs) { map.put(vob, cs); }
    public void put(Vob vob, int cs1, int cs2) { map.put(vob, cs1, cs2); }
    public void put(Vob vob, int[] cs ) { map.put(vob, cs); }


    public void clear(Dimension newSize) {
	this.size = newSize;
	this.coords.clear();
	this.matcher.clear();
	this.map.clear();
    }
	

    public void dump() {
	map.dump();
	coords.dump();
    }
}
